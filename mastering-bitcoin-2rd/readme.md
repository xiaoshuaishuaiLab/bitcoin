# 交易区块信息
通过https://www.blockchain.com/explorer/api/blockchain_api 或许即可


# bitcoin testnet faucet
https://coinfaucet.eu/en/btc-testnet/

通过上述地址，给自己在测试环境生成的地址发一些币，然后可以用Electrum Testnet 查看

# spv节点， hd 钱包
## 如果这个地址最新的一次交易是一年前，spv钱包能获取到余额吗
是的，即使地址的最新一次交易发生在一年前，SPV 钱包**仍然能够获取到该地址的正确余额**。

理解这一点，关键在于 SPV 钱包的同步机制和比特币的 UTXO 模型：

### SPV 钱包的同步机制

1.  **从哪里开始同步？**
    * 当一个 SPV 钱包首次启动或加载时（特别是新导入一个地址时），它会从区块链的**最近检查点 (Checkpoint)** 或者甚至从**创世区块 (Genesis Block)** 开始，下载**所有区块头**。区块头很小，下载速度很快。
    * 同时，它会使用**布隆过滤器 (Bloom Filter)** 向连接到的全节点发送它感兴趣的地址（包括你导入的那个地址）。

2.  **如何找到旧的交易？**
    * 全节点在收到 SPV 钱包的布隆过滤器后，会开始**回溯历史**。它会根据过滤器，从过去到现在，**查找所有与该布隆过滤器匹配的交易**。
    * 当全节点找到一个匹配的交易时（无论这个交易发生在一年前还是最近），它会将这个交易数据以及一个**梅克尔路径证明 (Merkle Path Proof)** 发送给 SPV 钱包。梅克尔路径证明能够验证该交易确实包含在某个特定区块中。

3.  **本地构建 UTXO 集合：**
    * SPV 钱包收到这些历史交易后，会逐一处理它们：
        * 如果是发送到该地址的交易输出，钱包会将其记录为新的 UTXO。
        * 如果是花费了该地址的交易输入，钱包会从其 UTXO 集合中移除相应的 UTXO。
    * 这个过程会**重建**该地址在历史上的所有 UTXO 状态。无论这笔交易多么久远，只要它存在于区块链上，并且被布隆过滤器捕获，SPV 钱包就能“看到”并处理它。

### 为什么一年前的交易也能获取？

* **区块链是不可变的账本：** 一旦交易被打包进区块并得到确认，它就永久地记录在区块链上，不会消失。
* **布隆过滤器扫描历史：** SPV 钱包并不只关心最新的交易。它会向全节点请求**所有**与其布隆过滤器匹配的交易，无论这些交易是最近的还是很久以前的。全节点会负责扫描其完整的区块链数据，找出所有匹配的交易并发送给 SPV 钱包。
* **UTXO 累积：** 余额是 UTXO 的总和。即使一年前的交易是地址收到的最后一笔 UTXO，它仍然是未花费的，所以会被包含在余额计算中。

### 潜在的挑战和注意事项：

1.  **首次同步时间：** 如果导入的地址有大量的历史交易，或者钱包是首次连接到网络并从头开始同步，那么下载所有相关的历史交易数据可能需要**相当长的时间**。虽然只下载区块头很快，但过滤后的交易数据也需要时间传输和处理。
2.  **全节点支持：** SPV 钱包的效率和准确性取决于它所连接的全节点是否正确地支持布隆过滤器协议，并能高效地提供历史交易数据。
3.  **误报处理：** 布隆过滤器可能存在误报，这意味着全节点可能会发送一些与你的地址无关的交易。SPV 钱包需要处理这些额外的、不相关的交易，但最终只会保留真正属于该地址的 UTXO。
4.  **隐私：** 再次强调，布隆过滤器虽然提高了效率，但因为其过滤特性，全节点可以大致推断出你感兴趣的地址，从而对你的隐私构成一定的泄露风险。

所以，核心答案是：**能**。SPV 钱包的设计就是为了能够同步和跟踪属于其钱包的地址（包括导入地址）的所有历史 UTXO，无论这些 UTXO 是何时产生的。


## 如果这个spv钱包是一个hd钱包，有很多地址，那是怎么获取到每个地址的余额呢
你提了一个非常核心的问题，涉及到 HD 钱包在 SPV 环境下管理大量地址的复杂性。对于一个 SPV HD 钱包（例如 BitcoinJ 的 `Wallet` 或 Electrum），它获取并跟踪多个派生地址余额的方式，在核心原理上与单个地址类似，但有重要的优化和约定。

### 核心原理：扩展公钥 (xpub) 和地址发现

HD 钱包的核心在于，它可以通过一个**扩展公钥 (Extended Public Key - xpub)** 派生出无数个子公钥和对应的地址，而无需知道任何私钥。这是实现 SPV HD 钱包的关键。

1.  **初始同步和地址生成：**
    * 当你首次导入一个 HD 钱包（通过助记词），或者从一个已有的 HD 钱包文件加载时，钱包首先会从种子派生出**主私钥和主公钥**。
    * 然后，它会根据预定义的**派生路径 (Derivation Path)**（例如 BIP44, BIP49, BIP84 等），派生出一定数量的**扩展公钥 (xpub)**。
    * 从这些 xpub（尤其是接收地址链和找零地址链的 xpub），钱包能够**确定性地生成**所有需要被监控的地址。

2.  **布隆过滤器 (Bloom Filter) 的升级：**
    * 对于单个地址，布隆过滤器只包含一个地址的哈希。
    * 对于 HD 钱包，由于地址数量庞大且是动态生成的，钱包不会将**所有可能**的地址都放入布隆过滤器。
    * 相反，它会将**当前已生成且需要监控的地址**的哈希（以及可能是一些相关的交易哈希）放入布隆过滤器。
    * **关键机制：地址发现与“地址空白限制 (Address Gap Limit)”**
        * HD 钱包会根据 BIP（如 BIP44）规定的**“地址空白限制” (Address Gap Limit)** 原则来派生和监控地址。
        * 这个限制通常是 20（可配置）。这意味着钱包会持续派生地址，直到它发现**连续 N 个派生地址没有任何交易活动**。
        * 当达到这个限制时，钱包会认为它已经“看到了”所有已使用的地址，并停止向前派生和监控。

3.  **同步和 UTXO 聚合：**
    * 钱包将包含这些地址的布隆过滤器发送给连接到的全节点。
    * 全节点根据过滤器，从创世区块开始（或最近的同步点），扫描其完整的区块链数据，找出所有匹配的交易，并将这些交易及梅克尔路径证明发送给 SPV 钱包。
    * SPV 钱包接收这些交易后，会：
        * **验证**每笔交易的梅克尔路径，确保其包含在有效的区块中。
        * **解析**交易，识别出属于其**任何一个派生地址**的 UTXO。
        * 钱包会维护一个**所有已知地址的 UTXO 集合**。
        * 对于每个 UTXO，钱包会记录它属于哪个具体的地址。

4.  **计算单个地址余额：**
    * 一旦同步完成，钱包就拥有了所有其所管理的地址的 UTXO 数据。
    * 要获取某个特定地址的余额，钱包只需**遍历其所有 UTXO**，并筛选出那些属于该特定地址的 UTXO，然后将它们的金额相加。
    * **`Wallet.getBalance()` 方法：** BitcoinJ 的 `Wallet.getBalance()` 方法默认返回整个钱包（所有派生地址）的总余额。如果你需要单个地址的余额，你需要像之前示例中那样，手动遍历 `wallet.calculateAllSpendableCoins()` 并根据 `outputAddress.equals(targetAddress)` 进行筛选。

### 总结流程：

1.  **从助记词/种子派生主密钥和扩展公钥。**
2.  **根据派生路径（如 BIP44）和“地址空白限制”，生成并管理一个需要监控的地址列表。**
3.  **构建一个包含这些地址的布隆过滤器，并将其发送给比特币网络中的全节点。**
4.  **全节点根据布隆过滤器筛选并发送相关的历史交易（以及梅克尔证明）。**
5.  **SPV 钱包接收、验证这些交易，并更新其内部的 UTXO 数据库，记录每个 UTXO 所属的地址。**
6.  **要获取某个特定地址的余额，遍历钱包的 UTXO 集合，筛选出属于该地址的 UTXO，并求和。**

这个机制使得 SPV HD 钱包能够高效地管理和追踪成千上万个派生地址的余额，而无需下载整个区块链，同时保持了良好的隐私性（通过使用多个地址）。

# electrum
bitcoinJ的peer同步太慢了，改成electrum的json rpc 获取相关数据 